
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Electron &#8212; MSE672: Introduction to TEM Spring 2021 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Atomic Form Factor" href="CH2_02-Atomic_Form_Factor.html" />
    <link rel="prev" title="Diffraction" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>
<p><strong>Chapter 2:</strong><a class="reference internal" href="Ch2_00-Diffraction.html"><span class="doc">Diffraction</span></a></p>
<hr style="height:1px;border-top:4px solid #FF8200" /><div class="section" id="The-Electron">
<h1>The Electron<a class="headerlink" href="#The-Electron" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://raw.githubusercontent.com/gduscher/MSE672-Introduction-to-TEM//main/Diffraction/CH2_01-Electron.ipynb">Download</a></p>
<p><a class="reference external" href="https://colab.research.google.com/github/gduscher/MSE672-Introduction-to-TEM/blob/main/Diffraction/CH2_01-Electron.ipynb"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<p>part of</p>
<p><a class="reference internal" href="../_MSE672_Intro_TEM.html"><span class="doc">MSE672: Introduction to Transmission Electron Microscopy</span></a></p>
<p>by Gerd Duscher, Spring 2021</p>
<p>Microscopy Facilities Joint Institute of Advanced Materials Materials Science &amp; Engineering The University of Tennessee, Knoxville</p>
<p>Background and methods to analysis and quantification of data acquired with transmission electron microscopes.</p>
<p>First we load the code to make figures from pyTEMlib ## Import packages for figures and ### Check Installed Packages</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>import sys
from pkg_resources import get_distribution, DistributionNotFound

def test_package(package_name):
    &quot;&quot;&quot;Test if package exists and returns version or -1&quot;&quot;&quot;
    try:
        version = get_distribution(package_name).version
    except (DistributionNotFound, ImportError) as err:
        version = &#39;-1&#39;
    return version

# Colab setup ------------------
if &#39;google.colab&#39; in sys.modules:
    !pip install pyTEMlib -q
# pyTEMlib setup ------------------
else:
    if test_package(&#39;pyTEMlib&#39;) &lt; &#39;0.2021.1.9&#39;:
        print(&#39;installing pyTEMlib&#39;)
        !{sys.executable} -m pip install  --upgrade pyTEMlib -q
# ------------------------------
print(&#39;done&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
done
</pre></div></div>
</div>
<div class="section" id="Load-the-plotting-and-figure-packages">
<h2>Load the plotting and figure packages<a class="headerlink" href="#Load-the-plotting-and-figure-packages" title="Permalink to this headline">¶</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>import sys
if &#39;google.colab&#39; in sys.modules:
    %pylab --no-import-all inline
else:
    %pylab --no-import-all notebook

import scipy.constants as const  #scientific constants
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Populating the interactive namespace from numpy and matplotlib
</pre></div></div>
</div>
<div class="section" id="Interaction-of-Common-Particles-with-Matter">
<h3>Interaction of Common Particles with Matter<a class="headerlink" href="#Interaction-of-Common-Particles-with-Matter" title="Permalink to this headline">¶</a></h3>
<p>We generally use electron, photons, and neutrons for diffraction/scattering experiments.</p>
<p>These particles interact with differently with matter:</p>
<table style="width:80%"><tr><td><p>X-rays</p>
</td><td><p><span class="math notranslate nohighlight">\(\leftrightarrow\)</span></p>
</td><td><p>electron density</p>
</td></tr><tr><td><p>neutrons</p>
</td><td><p><span class="math notranslate nohighlight">\(\leftrightarrow\)</span></p>
</td><td><p>mass of nucleus</p>
</td></tr><tr><td><p>neutrons</p>
</td><td><p><span class="math notranslate nohighlight">\(\leftrightarrow\)</span></p>
</td><td><p>magnetic moment</p>
</td></tr><tr><td><p>electrons</p>
</td><td><p><span class="math notranslate nohighlight">\(\leftrightarrow\)</span></p>
</td><td><p>screened charge of nucleus</p>
</td></tr></table><p>We will deal with the nature of electrons more closely in the following</p>
</div>
<div class="section" id="Non-relativistic-de-Broglie-Wavelength">
<h3>Non-relativistic de Broglie Wavelength<a class="headerlink" href="#Non-relativistic-de-Broglie-Wavelength" title="Permalink to this headline">¶</a></h3>
<p>The electron is a elementary particle with spin <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> (lepton).</p>
<p><strong>Non–relativistic De Broglie wavelength</strong> of electron:</p>
<p><span class="math notranslate nohighlight">\(\lambda = \frac{h}{p} = \frac{h}{\sqrt{2m_0E_{kin}}} \approx \frac{1.22}{\sqrt{E_{kin}}}\)</span></p>
<p>E is the kinetic energy of the electron: $E_{kin} = eU $ [eV].</p>
<p>The wave length in a TEM is usually a couple of picometers . This is a factor of 100 smaller than your XRD-source.</p>
<p>Obvioulsy, we are in the wave picture right now.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>## input
acceleration_voltage_V = U = 100.0 *1000.0 #V

## energy
E_kin = eV = const.e * acceleration_voltage_V  # potential

wave_length_m = const.h/np.sqrt(2*const.m_e*E_kin) # non-relativistic wavelength in m


##please note that we will keep all length units in nm if possible.
##otherwise we useonly SI units!!!
wave_length_nm = wave_length_m *1e9 # now in nm

print(np.sqrt(2/const.m_e*E_kin)/const.c)

print(f&#39;Classic wave length is {wave_length_nm*1000.:.2f} pm for acceleration voltage {acceleration_voltage_V/1000.:.1f} kV&#39;)
# Notice that we change units in the output to make them most readable.

print(f&#39; which is a velocity of {np.sqrt(2/const.m_e*E_kin):.2f} m/s or {np.sqrt(2/const.m_e*E_kin)/const.c*100:.2f}% of the speed of light&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.6256118898444742
Classic wave length is 3.88 pm for acceleration voltage 100.0 kV
 which is a velocity of 187553726.21 m/s or 62.56% of the speed of light
</pre></div></div>
</div>
</div>
<div class="section" id="Relativistic-Correction">
<h3>Relativistic Correction<a class="headerlink" href="#Relativistic-Correction" title="Permalink to this headline">¶</a></h3>
<p>In the table below we see that the speeds of the electron is rather close to the speed of light <span class="math notranslate nohighlight">\(c\)</span></p>
<p>The formula for relativistic corrected wavelength is: <span class="math notranslate nohighlight">\(\lambda = \frac{h}{\sqrt{2m_e E_{kin} *(1+\frac{E_{kin}}{2 m_e c^2})}}\)</span></p>
<p><strong>Please note:</strong> All units are internally in SI units: kg, s, V, J, except the length wihich is in nm!</p>
<p>We multiply with the appropriate factors for the output</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Input: Acceleration Voltage
E0 = acceleration_voltage = 200.0 *1000.0 #V

E_kin = eV = const.e * acceleration_voltage #potential

#relativisitic wavelength
wave_length = const.h/np.sqrt(2*const.m_e*E_kin*(1+E_kin/(2*const.m_e*const.c**2))) #in m

print(f&#39;The relativistically corrected wave length is {wave_length*1e12:.2f} pm for acceleration voltage {acceleration_voltage/1000:.1f} kV&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The relativistically corrected wave length is 2.51 pm for acceleration voltage 200.0 kV
</pre></div></div>
</div>
<p>100kV : <span class="math notranslate nohighlight">\(\lambda\)</span> = 4 pm <span class="math notranslate nohighlight">\(&lt;\)</span> than diameter an atom</p>
<p>The reltivistic parameters are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 42%" />
<col style="width: 31%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>E (keV)</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(\lambda\)</span> (pm)</p></th>
<th class="head"><p>M/m<span class="math notranslate nohighlight">\(_0\)</span></p></th>
<th class="head"><p>v/c</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10</p></td>
<td><p>12.2</p></td>
<td><p>1.0796</p></td>
<td><p>0.1950</p></td>
</tr>
<tr class="row-odd"><td><p>30</p></td>
<td><p>6.98</p></td>
<td><p>1.129</p></td>
<td><p>0.3284</p></td>
</tr>
<tr class="row-even"><td><p>100</p></td>
<td><p>3.70</p></td>
<td><p>1.1957</p></td>
<td><p>0.5482</p></td>
</tr>
<tr class="row-odd"><td><p>200</p></td>
<td><p>2.51</p></td>
<td><p>1.3914</p></td>
<td><p>0.6953</p></td>
</tr>
<tr class="row-even"><td><p>400</p></td>
<td><p>1.64</p></td>
<td><p>1.7828</p></td>
<td><p>0.8275</p></td>
</tr>
<tr class="row-odd"><td><p>1000</p></td>
<td><p>0.87</p></td>
<td><p>2.9569</p></td>
<td><p>0.9411</p></td>
</tr>
</tbody>
</table>
<p>The same functionality (and code) is used in the KinsCat Library and we can test the values of above table.</p>
<p>Please change the acceleration voltage (<strong>acceleration_voltage</strong>) above.</p>
</div>
</div>
<div class="section" id="Relativistic-velocity">
<h2>Relativistic velocity<a class="headerlink" href="#Relativistic-velocity" title="Permalink to this headline">¶</a></h2>
<div class="math notranslate nohighlight">
\[\frac{v^2}{c^2} = \frac{E_{kin}(E_{kin}+2m_e c^2)}{(E_{kin}+m_e c^2)^2}\]</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>v = np.sqrt(E_kin*(E_kin+2*const.m_e*const.c**2)/(E_kin+const.m_e*const.c**2)**2)*const.c

print(f&#39;The classic velocity of the electron  is {np.sqrt(2/const.m_e*E_kin):.2f} m/s or {np.sqrt(2/const.m_e*E_kin)/const.c*100:.2f}% of the speed of light&#39;)
print(f&#39;The relativistic velocity of the electron  is {v:.2f} m/s or {v/const.c*100:.2f}% of the speed of light&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The classic velocity of the electron  is 265241023.28 m/s or 88.47% of the speed of light
The relativistic velocity of the electron  is 208450034.42 m/s or 69.53% of the speed of light
</pre></div></div>
</div>
<div class="section" id="That-means-that-the-resolution-is-not-limited-by-the-wavelength!">
<h3>That means that the resolution is not limited by the wavelength!<a class="headerlink" href="#That-means-that-the-resolution-is-not-limited-by-the-wavelength!" title="Permalink to this headline">¶</a></h3>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Import Kinematic Scattering Library
import pyTEMlib.KinsCat as ks         # Kinematic sCattering Library

acceleration_voltage= 30*1e3
wave_length = ks.get_wavelength(acceleration_voltage)
print(f&#39;The relativistically corrected wave length is {wave_length*1e3:.2f} pm for acceleration voltage {acceleration_voltage/1000:.1f} kV&#39;)

# Wavelength in 1/nm
def get_wavelength(E0):
    &quot;&quot;&quot;
    Calculates the relativistic corrected de Broglie wave length of an electron

    Input:
    ------
        acceleration voltage in volt
    Output:
    -------
        wave length in 1/nm
    &quot;&quot;&quot;

    eV = const.e * E0
    return const.h/np.sqrt(2*const.m_e*eV*(1+eV/(2*const.m_e*const.c**2)))*10**9

</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The relativistically corrected wave length is 6.98 pm for acceleration voltage 30.0 kV
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>help(ks.get_wavelength)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Help on function get_wavelength in module pyTEMlib.KinsCat:

get_wavelength(e0)
    Calculates the relativistic corrected de Broglie wave length of an electron

    Input:
    ------
        acceleration voltage in volt
    Output:
    -------
        wave length in nm

</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>help(ks)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Help on module pyTEMlib.KinsCat in pyTEMlib:

NAME
    pyTEMlib.KinsCat

DESCRIPTION
    KinsCat
    Kinematic Scattering Theory
    Copyright by Gerd Duscher

    The University of Tennessee, Knoxville
    Department of Materials Science &amp; Engineering

    Sources:
       Scattering Theory:
       Zuo and Spence, &#34;Advanced TEM&#34;, 2017

       Spence and Zuo, Electron Microdiffraction, Plenum 1992

       Atomic Form Factor:
           Kirkland: Advanced Computing in Electron Microscopy 2nd edition
           Appendix C

    Units:
        everything is in SI units, except length is given in nm.

    Usage:
        See the notebooks for examples of these routines

    All the input and output is done through a dictionary

FUNCTIONS
    Zuo_fig_3_18()
        Input for Figure 3.18 in Zuo and Spence &#34;Advanced TEM&#34;, 2017

        This input acts as an example as well as a reference

        Returns:
            dictionary: tags is the dictionary of all input and output paramter needed to reproduce that figure.

    ball_and_stick(tags, extend=1, max_bond_length=0.0)
        Calculates the data to plot a ball and stick model

        Input:
            tags: dictionary containing the &#39;unit_cell&#39;, &#39;base&#39; and &#39;elements&#39; tags.

            extend: 1 or 3 integers
                The *extend* argument scales the effective cell in which atoms
                will be included. It must either be a list of three integers or a single
                integer scaling all 3 directions.  By setting this value to one,
                all  corner and edge atoms will be included in the returned cell.
                This will of cause make the returned cell non-repeatable, but this is
                very useful for visualisation.

            max_bond_length: 1 float
                The max_bond_length argument defines the distance for which a bond will be shown.
                If max_bond_length is zero, the tabulated atom radii will be used.

        Output:

            corners,balls, Z, bonds: lists
                These lists can be used to plot the
                unit cell:
                    for x, y, z in corners:
                        l=mlab.plot3d( x,y,z, tube_radius=0.002)
                bonds:
                    for x, y, z in bonds:
                        mlab.plot3d( x,y,z, tube_radius=0.02)
                and atoms:
                    for i,atom in enumerate(balls):
                        mlab.points3d(atom[0],atom[1],atom[2],
                                      scale_factor=0.1,##ks.vdw_radii[Z[i]]/5,
                                      resolution=20,
                                      color=tuple(ks.jmol_colors [Z[i]]),
                                      scale_mode=&#39;none&#39;)

            Please note that you&#39;ll need the *Z* list for coloring, or for radii that depend on elements

    bcc(lattice_parameter, elements)
        BCC structure

        Input:
            lattice parameter in nm and
            elements as a list or a string of a single element

        Returns:
            unit cell , base and relative atom positions

    check_sanity(tags)
        Check sanity of input parameters

    circles(x, y, s, c=&#39;b&#39;, vmin=None, vmax=None, **kwargs)
        Make a scatter plot of circles.

        Similar to plt.scatter, but the size of circles are in data scale.

        Parameters

            x, y : scalar or array_like, shape (n, )
                Input data
            s : scalar or array_like, shape (n, )
                Radius of circles.
            c : color or sequence of color, optional, default : &#39;b&#39;
                `c` can be a single color format string, or a sequence of color
                specifications of length `N`, or a sequence of `N` numbers to be
                mapped to colors using the `cmap` and `norm` specified via kwargs.
                Note that `c` should not be a single numeric RGB or RGBA sequence
                because that is indistinguishable from an array of values
                to be colormapped. (If you insist, use `color` instead.)
                `c` can be a 2-D array in which the rows are RGB or RGBA, however.
            vmin, vmax : scalar, optional, default: None
                `vmin` and `vmax` are used in conjunction with `norm` to normalize
                luminance data.  If either are `None`, the min and max of the
                color array is used.
            kwargs : `~matplotlib.collections.Collection` properties
                Eg. alpha, edgecolor(ec), facecolor(fc), linewidth(lw), linestyle(ls),
                norm, cmap, transform, etc.
        Returns

            paths : `~matplotlib.collections.PathCollection`
        Examples
            a = np.arange(11)
            circles(a, a, s=a*0.2, c=a, alpha=0.5, ec=&#39;none&#39;)
            plt.colorbar()
        License
            This code is under [The BSD 3-Clause License]
            (http://opensource.org/licenses/BSD-3-Clause)

    cubic(a)
        Cubic lattice of dimensions a x a x a.

    dichalcogenide(a, c, u, elements)
        Dichalcogenide structure

        Input:
            a, c: floats - lattice parameters
            u: float - relative shift parameter
            elements: string of element or list of strings of elements

        Returns:
            unit_cell, base, atoms

    diffraction_pattern(tags, grey=False)
        Determines how to plot diffraction pattern from kinematic scattering data.

        Input:
            tags : dictionary of kinematic scattering data

        Returns:
            tags: dictionary that now contains all information of how to plot any diffraction pattern
            plot

    example()
        same as Zuo_fig_3_18

    fcc(lattice_parameter, elements)
        FCC structure

        Input:
            lattice parameter in nm and
            elements as a list or a string of a single element

        Returns:
            unit cell , base and relative atom positions

    feq(element, q)
        Atomic form factor parametrized in 1/Angstrom but converted to 1/nm

        The atomic form factor is from Kirkland: Advanced Computing in Electron Microscopy 2nd edition, Appendix C.

        Input:
            element: string of element name
            q:  now magnitude of scattering vector in 1/nm -- (=&gt; exp(-i*g.r), physics negative convention)

    from_parameters(a, b, c, alpha, beta, gamma)
        Create a unit cell  using lengths and angles (in degrees).

    get_rotation_matrix(zone, verbose=False)
         Calculates the rotation matrix to rotate the zone axis parallel to the cartasian z-axis.

         We use spherical coordinates to first rotate around the z-axis and then around the y-axis.
         This makes it easier to apply additional tilts, than to use the cross product to determine a single rotation
         axis (Rodrigues Formula)

         INPUT:
         ------
          - zone axis has to be in cartesian coordinates also.
         The dot product of zone axis  and unit cell will accomplish that.

        Output:
        -------
         - rotation_matrix
         - theta (degrees)
         - phi (degrees)

    get_symmetry(unit_cell, base, atoms)
        Symmetry analysis with spglib

        spglib must be installed

    get_wavelength(e0)
        Calculates the relativistic corrected de Broglie wave length of an electron

        Input:
        ------
            acceleration voltage in volt
        Output:
        -------
            wave length in nm

    h5_add_crystal_structure(h5_file, crystal_tags)
        Adds the basic crystal information to a pyNSID style hdf5 file.

        example usage:
        &gt;&gt; crystal_tags = ks.structure_by_name(h5_file, &#39;Graphite&#39;)
        &gt;&gt; ks.add_crystal_structure(h5_file, crystal_tags)

    h5_add_to_structure(structure_group, crystal_tags)
        add dictionary as structure group

    kinematic_scattering(tags, verbose=False)
        All kinematic scattering calculation

        Calculates Bragg spots, Kikuchi lines, excess, and deficient HOLZ lines

        Input:
            a dictionary with crystal structure:
                &#39;unit_cell&#39;, &#39;base&#39; &#39;elements&#39;
            and with experimental parameters:
                &#39;acceleration_voltage_V&#39;, &#39;zone_hkl&#39;, &#39;Sg_max&#39;, &#39;hkl_max&#39;
            Optional parameters are:
                &#39;mistilt&#39;, convergence_angle_mrad&#39;, and &#39;crystal_name&#39;
            vebose = True will give extended output of the calculation
        Output to dictionary:
            There are three sub_dictionaries:
                [&#39;allowed&#39;], [&#39;forbidden&#39;], and [&#39;HOLZ&#39;]
                [&#39;allowed&#39;] and [&#39;forbidden&#39;] dictionaries contain:
                    [&#39;Sg&#39;], [&#39;hkl&#39;], [&#39;g&#39;], [&#39;structure factor&#39;], [&#39;intensities&#39;],
                    [&#39;ZOLZ&#39;], [&#39;FOLZ&#39;], [&#39;SOLZ&#39;], [&#39;HOLZ&#39;], [&#39;HHOLZ&#39;], [&#39;label&#39;], and [&#39;Laue_zone&#39;]
                the [&#39;HOLZ&#39;] dictionary contains:
                    [&#39;slope&#39;], [&#39;distance&#39;], [&#39;theta&#39;], [&#39;g deficient&#39;], [&#39;g excess&#39;], [&#39;hkl&#39;], [&#39;intensities&#39;],
                    [&#39;ZOLZ&#39;], [&#39;FOLZ&#39;], [&#39;SOLZ&#39;], [&#39;HOLZ&#39;], and  [&#39;HHOLZ&#39;]
                Please note that the Kikuchi lines are the HOLZ lines of ZOLZ

                There are also a few parameters stored in the main dictionary:
                    [&#39;wave_length_nm&#39;], [&#39;reciprocal_unit_cell&#39;], [&#39;inner_potential_V&#39;], [&#39;incident_wave_vector&#39;],
                    [&#39;volume&#39;], [&#39;theta&#39;], [&#39;phi&#39;], and [&#39;incident_wave_vector_vacuum&#39;]

    make_pretty_labels(hkls, hex_label=False)
        Make pretty labels

        Input:
            hkls: a numpy array with all the Miller indices to be labeled

        Optional:
            hex_label: if True this will make for Miller indices.

        Output:
            list of labels in Latex format

    metric_tensor(matrix)
        The metric tensor of the lattice.

        Usage:
            metric_tensor(unit_cell)

    perovskite(lattice_parameter, elements)
        Perovskite structure

        Input:
            lattice_parameter: float in nm
            elements: string of element or list of strings of elements

        Returns:
            unit_cell, base, atoms

    plotCBED(tags, grey=False)
        Plot CBED Pattern

    plotHOLZ(tags, grey=False)
        Plot HOLZ Pattern

    plotKikuchi(tags, grey=False)
        Plot Kikuchi Pattern

    plotSAED(tags, gray=False)
        Plot SAED Pattern of single crystal

    plot_diffraction_pattern(tags, grey=False)
        Plot any diffraction pattern based on content in dictionary

    plot_unitcell(tags)
        Simple plot of unit cell

    plot_unitcell_mayavi(tags)
        Makes a 3D plot of crystal structure

        Input:

            Dictionary with tags: &#39;unit_cell, &#39;elements&#39;, &#39;base&#39;

        Output:

            3D plot

        Dependencies:

            ball_and_stick function of KinsCat
            mlab of mayavi

    read_poscar()
        Open file dialog to select a POSCAR file from VASP

    ring_pattern_calculation(tags, verbose=False)
        Calculate the ring diffraction pattern of a crystal structure

        Input:
            tags: dictionary of crystal structure
        Output:
            tags: dictionary with diffraction information added

    rocksalt(lattice_parameter, elements)
        Rocksalt structure

        Input:
            lattice_parameter: float in nm
            elements: string of element or list of strings of elements
        Returns:
            unit_cell, base, atoms

    structure_by_name(crystal)
        Provides unit cell as a structure matrix, the list of elements and the atom base

        Input:
        ------
            crystal name as string:
            type &#34;print(ks.crystal_data_base.keys())&#34; for a list of pre-defined crystal structures

            Please note that the chemical expressions are case sensitive.

        Output:
        ------
            new dictionary with the following keys:

            [&#39;unit_cell&#39;]: the structure matrix
            [&#39;base&#39;]:      relative coordinates of atoms
            [&#39;elements&#39;]:     name of elements in same order as base

            an empty dictionary will be returned if the name is not recognized.

    tetragonal(a, c)
        Tetragonal unit cell of dimensions a x a x c.

    vector_norm(g)
        Length of vector

    wurzite(a, c, u, elements)
        Wurzite structure

        Input:
            a, c: floats - lattice parameters in nm
            elements: string of element or list of strings of elements

        Returns:
            unit_cell, base, atoms

    zinc_blende(lattice_parameter, elements)
        Zinc blende structure

        Input:
            lattice_parameter: float in nm
            elements: string of element or list of strings of elements

        Returns:
            unit_cell, base, atoms

    zone_mistilt(zone, angles)
        Rotation of zone axis by mistilt

        Input:
            zone: zone axis in Miller indices
            angles: list of mistilt angles in degree

        Returns:
            rotation matrix (3x3)

DATA
    a_l = 0.4209
    alpha_l = 90
    b_l = 0.2464
    base_l = array([[0.        , 0.        , 0.        ],
       ... ],
          ...
    beta_l = 90
    c_l = 0.6711
    cdb = {&#39;Ag&#39;: {&#39;a&#39;: 0.40853, &#39;crystal_name&#39;: &#39;silver&#39;, &#39;elements&#39;: [&#39;Ag...
    crystal_data_base = {&#39;Ag&#39;: {&#39;a&#39;: 0.40853, &#39;crystal_name&#39;: &#39;silver&#39;, &#39;e...
    electronFF = {&#39;Ac&#39;: {&#39;Z&#39;: 89, &#39;bond_length&#39;: [2.09, 1.88, 1.7, 0], &#39;ch...
    gamma_l = 60
    jmol_colors = array([[1.   , 0.   , 0.   ],
           [0.851, 1. ...02, 0...

FILE
    c:\users\gduscher\anaconda3\lib\site-packages\pytemlib\kinscat.py


</pre></div></div>
</div>
</div>
<div class="section" id="Particle-Flux-and-Current">
<h3>Particle Flux and Current<a class="headerlink" href="#Particle-Flux-and-Current" title="Permalink to this headline">¶</a></h3>
<p>It is important todetermine the order of magitude of how many electrons are hitting the sample.</p>
<p>The electron sources deliver in the order of <span class="math notranslate nohighlight">\(\mu\)</span>A current, but most of these electrons are not used.</p>
<p>In a modern electron microscope, we talk about a range of 1pA to 1nA in the electron beam.</p>
<p>We start with the defition of an Ampere:</p>
<div class="math notranslate nohighlight">
\[A = \frac{C}{s}\]</div>
<p>That definition is enough to calculate the number ofelectron per time unit (flux).</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>print(f&quot; elementary charge: {const.physical_constants[&#39;elementary charge&#39;][0]:.5g} {const.physical_constants[&#39;elementary charge&#39;][1]}&quot;)
print(f&#39;\n 1pA is {1e-12/const.e:.3} electrons/s&#39;)
print(f&#39; 10pA is {10e-12/const.e *1e-3 :.0f} electrons/ms&#39;)
print(f&#39;100pA is {100e-12/const.e*1 :.3} electrons/s&#39;)

print(f&#39;\n at 10pA an electron will hit the sample every {const.e/10e-12 * 1e9:.2f} ns &#39;)

</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
 elementary charge: 1.6022e-19 C

 1pA is 6.24e+06 electrons/s
 10pA is 62415 electrons/ms
100pA is 6.24e+08 electrons/s

 at 10pA an electron will hit the sample every 16.02 ns
</pre></div></div>
</div>
<p>We see that we have much lower fluence in the TEM than in a laser (how could they do femtosecond pulses otherwise).</p>
</div>
<div class="section" id="Navigation">
<h3>Navigation<a class="headerlink" href="#Navigation" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><strong>Back Chapter 1:</strong><a class="reference external" href="CH1_00-Introduction.ipynb">Introduction</a></p></li>
<li><p><strong>Next:</strong><a class="reference internal" href="CH2_02-Atomic_Form_Factor.html"><span class="doc">Atomic Form Factor</span></a></p></li>
<li><p><strong>Chapter 2:</strong><a class="reference external" href="CH2_00-_Diffraction.ipynb">Diffraction</a></p></li>
<li><p><strong>List of Content:</strong><a class="reference internal" href="../_MSE672_Intro_TEM.html"><span class="doc">Front</span></a></p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">MSE672: Introduction to TEM</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Course Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Introduction/index.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Diffraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Imaging/index.html">Imaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Spectroscopy/index.html">Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Instrument/index.html">Instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Lab_Course/index.html">Lab Course</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Diffraction</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Diffraction</a></li>
      <li>Next: <a href="CH2_02-Atomic_Form_Factor.html" title="next chapter">Atomic Form Factor</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Gerd Duscher.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/Diffraction/CH2_01-Electron.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>